"""LLM-based memory extraction."""
from openai import OpenAI
import os
import json
from dotenv import load_dotenv

load_dotenv()

# Initialize OpenAI client
_openai_client = None


def get_openai_client():
    """Get or create OpenAI client."""
    global _openai_client
    if _openai_client is None:
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY not found in environment variables")
        _openai_client = OpenAI(api_key=api_key)
    return _openai_client


def analyze_for_memory(message: str) -> dict:
    """
    Analyze user message to determine if it should be saved to memory.
    
    Args:
        message: User's message text
        
    Returns:
        {
            "should_write_memory": true/false,
            "memory_to_write": "cleaned memory text",
            "importance": int(1-5)
        }
    """
    try:
        client = get_openai_client()
        
        prompt = """You are a Long-Term Memory Evaluation Module.

Your purpose is to identify and extract information that is suitable for long-term memory and ignore anything temporary or task-specific.

Objective:
- Determine whether the input contains information that is appropriate for long-term memory.
- If so, extract only the stable, generalized, long-lasting part of it.
- If not, return nothing.

What Counts as Long-Term Memory:

Only capture information that is:

1. Stable Personal Preferences
   - General tendencies that remain true across time, such as:
     * travel style
     * general comfort preferences
     * preferred tone or style of interaction
     * broad habits or tendencies

2. Enduring Characteristics or Identity
   - Information that describes:
     * profession
     * long-term hobbies or interests
     * stable personal background
     * durable constraints (dietary, accessibility, lifestyle)

3. Long-Term Projects or Goals
   - Ongoing multi-step goals or commitments that extend beyond a single conversation.

4. Meta Interaction Preferences
   - General rules for how responses should be structured across all contexts:
     * likes short answers
     * prefers step-by-step breakdowns
     * prefers structured or concise output

5. Recurring Patterns
   - Information the user repeats often and that reflects a stable pattern.

What Must Be Ignored:

Do not capture any of the following:

A. Dates, Schedules, or Time-Bound Information
   - Examples: travel dates, deadlines, event schedules

B. Temporary Tasks or Requests
   - Instructions that apply only now: one search, one trip, one task, one problem

C. Context-Specific or One-Time Details
   - Anything that only matters within the current conversation.

D. Temporary Preferences
   - Valid "for this specific case" or "for this project only."

E. Numbers, IDs, Codes, Prices
   - Any numerical or highly specific data tied to a single event.

F. Mood or Emotional State
   - Momentary feelings or situational reactions.

G. Anything generated by the assistant
   - Only extract information that the user inherently expresses about themselves.

Generalization Rules:

If the input contains long-term information:
- Generalize it: Reduce to a short, general fact with lasting relevance.
- Remove specifics: No dates, times, counts, or one-off context.
- Keep only the essence: Extract only what will remain true across months.
- Avoid quoting: Represent the information in clean, paraphrased form.

If the input contains no long-term information, produce no output.

Decision Principle:
When uncertain, treat the information as short-term and output nothing.
It is better to miss a memory than to store irrelevant one-off details.

Return ONLY valid JSON:
{
  "should_write_memory": true/false,
  "memory_to_write": "condensed, generalized, long-term memory (empty if should_write_memory is false)",
  "importance": integer 1-5,
  "is_update": true/false,
  "is_deletion": true/false,
  "old_memory_text": "text of memory being updated/deleted (if applicable)"
}

Importance meaning:
1-2 = ignore (not useful or too temporary)
3   = useful but low priority (stable preference)
4   = important (enduring characteristic or significant preference)
5   = extremely important (core identity, critical constraint, or fundamental preference)

Memory operations:
- is_update: true if user is updating/changing a long-term preference (e.g., "I no longer prefer X" or "I changed my preference from X to Y")
- is_deletion: true if user is explicitly removing a long-term preference (e.g., "I don't prefer X anymore" or "Forget that I like X")
- old_memory_text: The generalized text of the memory being updated/deleted (e.g., "User prefers morning flights" if user says "I no longer prefer morning flights")

CRITICAL: Only set should_write_memory to true if the information meets the long-term memory criteria above. If it's temporary, task-specific, or context-bound, set it to false.

User message: """ + message
        
        response = client.chat.completions.create(
            model="gpt-4o-mini",  # Using gpt-4o-mini for cost efficiency
            messages=[
                {"role": "system", "content": "You are a Long-Term Memory Evaluation Module. Your purpose is to identify and extract only stable, generalized, long-lasting information suitable for long-term memory. Return only valid JSON."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            response_format={"type": "json_object"}
        )
        
        result_text = response.choices[0].message.content
        result = json.loads(result_text)
        
        # Validate and ensure correct types
        return {
            "should_write_memory": bool(result.get("should_write_memory", False)),
            "memory_to_write": str(result.get("memory_to_write", "")).strip(),
            "importance": int(result.get("importance", 1)),
            "is_update": bool(result.get("is_update", False)),
            "is_deletion": bool(result.get("is_deletion", False)),
            "old_memory_text": str(result.get("old_memory_text", "")).strip()
        }
        
    except Exception as e:
        print(f"[ERROR] Error in memory extraction: {e}")
        # Return default: don't save
        return {
            "should_write_memory": False,
            "memory_to_write": "",
            "importance": 1,
            "is_update": False,
            "is_deletion": False,
            "old_memory_text": ""
        }

